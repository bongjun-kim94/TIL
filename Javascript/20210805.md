# 화살표 함수 (arrow function)

    함수 표현식보다 단순하고 간결한 문법으로 함수를 만들 수 있다.

<pre>
    <code>
      // 화살표 함수 호출
      // ES5
      var sum = function(a, b) {
        return a + b;
      }
      console.log(sum(5,10));

      // ES6
      const sum = (a, b) => a + b;
      console.log(sum(5, 10));
    </code>
</pre>

# 동기 & 비동기

- 동기란? 발생하는 하나의 이벤트가 모두 끝날 때까지 다른 이벤트를 처리하지 못하고 이벤트가 모두 완료 된 후 다음 이벤트를 동작하는 실행 순서가 확실한 것을 동기적 방식이라 부른다.

- 비동기란? 특정 코드의 처리가 끝나기 전에 다음 코드를 실행할 수 있는 것을 뜻한다.
  연속적으로 발생하는 이벤트를 담은 후 완료되는 순서대로 일을 처리하는 실행 순서가 확실하지 않는 것을 비동기적 방식이라 한다.

- 비동기 처리를 하는 세 가지 방법
  - 콜백 함수 사용 - 가독성이 매우 떨어짐, 모든 콜백에서 각각 에러처리를 해야함
  - Promise
  - Promise를 활용한 async/ await

* Promise 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냅니다.
* resolve(성공)되는 값은 then 메소드의 인자로 넘어간다. then 메소드는 다시 Promise를 반환
* 반대로 reject(실패)되는 값은 catch 메소드의 인자로 넘어간다.

* async/await
  - promise를 더욱 쉽게 사용할 수 있도록 해주는 (ES8) 문법
  - 함수 앞부분에 async 키워드를 추가, 함수 내부의 promise앞에서 await 키워드를 사용
  - 코드가 간결해지지만, 에러 처리를 위해 try / catch 로 후속처리, 동기적인 코드 흐름으로 개발 가능

# this

- this - 선언이 아닌 호출에 따라 달라짐

- 일반함수의 this는 window(전역)을 가르키며, 화살표 함수의 this는 언제나 상위스코프의 this를 가르킴

- Call, Apply, Bind함수는 this를 바인딩 하기위한 방법
  - 메서드에 첫 번째 인수로 전달하는 객체에 바인딩
  - 일반함수에서의 this는 undefined가 바인딩 됨.

# 비구조화 할당

    배열이나 객체의 속성을 해체하여, 그 값을 개별 변수에 담을 수 있게 함

<pre>
  <code>
    const [a, b, c] = [1, 2, 3];
    console.log(a); // 1
    console.log(a, b, c); // 1, 2, 3

    const obj = {x: 'red', y: 'black', z: 'yellow'};
    let {x, y, z} = obj; // obj.x 
    console.log(x, y, z);
  </code>
</pre>
